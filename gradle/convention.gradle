status = version.toString().contains('SNAPSHOT') ? 'snapshot' : 'release'

subprojects {project ->
    status = rootProject.status

    if (project in publishedModules) {
        apply plugin: 'java'
        sourceCompatibility = 1.8

        // Restore status after Java plugin

        javadoc {
            options.memberLevel = org.gradle.external.javadoc.JavadocMemberLevel.PROTECTED
            options.author = true
            options.header = project.name
            options.addStringOption('Xdoclint:html,syntax,reference', '-quiet')
            options.links('http://docs.oracle.com/javase/8/docs/api/',
                          'http://typesafehub.github.com/config/latest/api/',
                          "http://google.github.io/guava/releases/20.0/api/docs/")
        }

        task sourcesJar(type: Jar, dependsOn: classes) {
            classifier = 'sources'
            baseName = project.name
            dependsOn tasks.classes
            from sourceSets.main.allSource
            classifier 'sources'
            extension 'jar'


        }

        task javadocJar(type: Jar) {
            classifier = 'javadoc'
            baseName = project.name
            dependsOn tasks.javadoc
            from tasks.javadoc.destinationDir
            classifier 'javadoc'
            extension 'jar'


        }

        tasks.withType(Jar) {
            group 'Jars'
            from(project.projectDir) {
                include 'LICENSE.md'
                into 'META-INF'
            }
        }

        def normalizeVersion = {versionLiteral ->
            try {
                (versionLiteral =~ /(\d+)\.(\d+)\.(\d+).*/)[0][1..3].join('.')
            } catch (x) {
                throw new GradleException(
                        "Version '$versionLiteral' does not match version pattern, e.g." + " 5.0" +
                                ".0-QUALIFIER")
            }
        }

        jar {
            manifest {
                attributes(
                        'Created-By': "${System.properties['java.version']} (${System.properties['java.vendor']} ${System.properties['java.vm.version']})".
                                toString(),
                        'Built-By': builtByValue,
                        'Build-Date': project.buildDate,
                        'Build-Time': project.buildTime,
                        'Build-Revision': buildRevision,
                        'Built-Gradle': gradle.gradleVersion,
                        'Specification-Title': project.name,
                        'Specification-Version': normalizeVersion(project.version),
                        'Specification-Vendor': 'softcake.org',
                        'Implementation-Title': project.name,
                        'Implementation-Version': project.version,
                        'Implementation-Vendor': 'softcake.org')

            }
            baseName = project.name
        }

        artifacts {
            archives sourcesJar
            archives javadocJar
        }
        apply from: "$rootDir/gradle/publishing.gradle"
        apply from: "$rootDir/gradle/bintray.gradle"
        apply from: "$rootDir/gradle/artifactory.gradle"
        String branch = versioning.info.branch
        artifactoryPublish.skip true
        final BRANCH_NAMES_PATTERN = /^(?:release[-\/])?[0-9]+(\.[0-9]+)?\.x$|^(?:feature[-\/]|hotfix[-\/]|develop|master)?$/
        apply plugin: 'maven-publish'

        if (!version.toString().endsWith('-SNAPSHOT')) {
            publish.dependsOn getTasksByName("bintrayUpload", true)
            if (branch.matches(BRANCH_NAMES_PATTERN)) {
                bintrayUpload.dependsOn rootProject.getTasksByName("sonarqube", true)
            }
        } else if ((System.getenv('TRAVIS_PULL_REQUEST') ?: "false") == "false") {
             publish.dependsOn getTasksByName("artifactoryPublish", true)
            if (branch.matches(BRANCH_NAMES_PATTERN)) {
                 artifactoryPublish.dependsOn rootProject.getTasksByName("sonarqube", true)
            }
        }

    }
    if (project in integTestModules) {
        apply plugin: "java"
        apply from: "$rootDir/gradle/integTest.gradle"

    }
    if (project in benchmarkModules) {
        apply plugin: "java"
        apply from: "$rootDir/gradle/benchmark.gradle"

    }
}
apply plugin: "base"

task cleanRoot(type: Delete) {
    delete "$buildDir"
    followSymlinks = true
    mustRunAfter "clean"
}

task aggregateJavadocs(type: Javadoc) {
    group = "Documentation"
    description = "Generates aggregated Javadocs"
    title = "Softcake ${version} gradle-template"

    dependsOn {
        publishedModules.javadocJar
    }

    options.memberLevel = org.gradle.external.javadoc.JavadocMemberLevel.PROTECTED
    options.author = true
    options.header = rootProject.description
    options.splitIndex = true
    options.addStringOption('Xdoclint:html,syntax,reference', '-quiet')
    options.jFlags '-Xmx1g'
    options.links('http://docs.oracle.com/javase/8/docs/api/',
                  'http://typesafehub.github.com/config/latest/api/',
                  "http://google.github.io/guava/releases/20.0/api/docs/")

    source publishedModules.sourceSets.main.allJava

    maxMemory = "1024m"
    destinationDir = new File(buildDir, "docs/javadoc")

    doFirst {
        classpath = files(publishedModules.sourceSets.main.compileClasspath)
    }
}

tasks.withType(JavaCompile) {
    options.encoding = 'UTF-8'
    //options.compilerArgs << '-Xlint:all'
}

task wrapper(type: Wrapper) {
    description = "Generates gradlew and gradlew.bat scripts"
    gradleVersion = '3.2.1'
    distributionUrl = "https://services.gradle.org/distributions/gradle-$gradleVersion-all.zip"
}



task aggregateSourcesJar(type: Jar) {
    classifier = 'sources'
    dependsOn publishedModules.sourcesJar
    from {publishedModules.sourceSets.main.allSource}
    from("LICENSE.txt", "README.md")
    classifier = 'sources'
    extension 'jar'
}

task aggregateJavadocJar(type: Jar) {
    classifier = 'javadoc'
    dependsOn aggregateJavadocs
    from aggregateJavadocs.destinationDir
    classifier 'javadoc'
    extension 'jar'

}

task aggregateJar(type: Jar) {
    manifest {
        attributes('Built-By': System.properties['user.name'],
                   'Created-By': System.properties['java.version'] + ' (' + System.properties['java.vendor'] + ' ' +
                           System.properties["java.vm.version"] + ')',

                   'Built-Gradle': gradle.gradleVersion,
                   'Specification-Title': project.name,
                   'Specification-Version': project.version.toString(),
                   'Specification-Vendor': 'Rene Neubert',
                   'Implementation-Title': project.name,
                   'Implementation-Version': project.version.toString(),
                   'Implementation-Vendor': 'Rene Neubert')
    }
    extension 'jar'
    dependsOn publishedModules.jar

    from publishedModules.sourceSets.main.output.classesDir
    from publishedModules.sourceSets.main.output.resourcesDir
    from("LICENSE.txt", "README.md")

}
artifacts {
    archives aggregateSourcesJar
    archives aggregateJavadocJar
    archives aggregateJar
}
tasks.withType(Jar) {
    group 'Jars'
    from(project.projectDir) {
        include 'LICENSE.md'
        into 'META-INF'
    }
}
task createAllJars(type: Jar) {
    dependsOn aggregateJavadocJar, aggregateJar, aggregateSourcesJar
}
